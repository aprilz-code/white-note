## 前言

在查看RocketMQ消费者分类时，一直有个疑惑,PushConsumer实现方式是注册一个消费监听器， 长轮询拉取消息，缓存本地，并按配置消费。这种不是属于'Pull'么,为啥叫官方叫Push呢？

> tips : 长轮询其实原理跟轮询差不多，都是采用轮询的方式。不过，如果服务端的数据没有发生变更，会 一直 hold 住请求，直到服务端的数据发生变化，或者等待一定时间超时才会返回。返回后，客户端又会立即再次发起下一次长轮询。

以下来着官方文档介绍：  
[RocketMQ官网-消费者分类](https://rocketmq.apache.org/zh/docs/featureBehavior/06consumertype)

#### PushConsumer

PushConsumers是一种高度封装的消费者类型，消费消息仅通过消费监听器处理业务并返回消费结果。消息的获取、消费状态提交以及消费重试都通过 Apache RocketMQ 的客户端SDK完成。

#### 使用方式

PushConsumer的使用方式比较固定，在消费者初始化时注册一个消费监听器，并在消费监听器内部实现消息处理逻辑。由 Apache RocketMQ 的SDK在后台完成消息获取、触发监听器调用以及进行消息重试处理。

![消费者分类](https://file.losey.top/blog/img-1679453262187.png)

## 正文

RocketMQ支持两种消息消费模式：推送式（push）和拉取式（pull）。
推送式消费是指消息在到达消费者时，RocketMQ会将消息直接推送给消费者。而拉取式消费则是由消费者主动向RocketMQ拉取消息。

虽然推送式消费看起来类似于消息中间件主动将消息推送给消费者，但实际上在底层实现上，也是使用了拉取式消费的方式。
RocketMQ推送式消费的核心原理是：消费者在拉取到一批消息后，会主动长时间阻塞等待新消息的到来，一旦有新消息到达，就会立即推送给消费者。

因此，即使使用了推送式消费，RocketMQ依然是基于拉取式消费实现的。
不过相比于纯粹的拉取式消费，推送式消费可以更加高效地利用网络资源，降低消息传输的延迟。