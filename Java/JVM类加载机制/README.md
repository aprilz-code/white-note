# JVM类加载机制

## 类加载器

虚拟机设计团队把加载动作放到JVM外部实现，以便于引用程序决定如何获取所需的类，JVM提供了三种类加载器

### 启动类加载器

Bootstrap ClassLoader，负责加载JAVA_HOME\lib目录中的，或通过-Xbootclasspath 参数指定路径下的，且被虚拟机认可（按文件名识别，如tr.jar）的类

### 扩展类加载器

Extension ClassLoader，负责加载JAVA_HOME\lib\ext目录中的，或通过java.ext.dirs系统变量指定路径中的类库。

### 应用程序类加载器

Application ClassLoader，负责加载用户路径（classpath）上的类库。JVM通过双亲委派进行类的加载，当然我们也可以通过继承java.lang.ClassLoader实现自定义的类加载器。

## 类加载过程

JVM类加载机制主要分为以下五个部分：加载、验证、准备、解析、初始化

### 加载

加载是类加载过程中的一个阶段，这个阶段会在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的入口。注意这里不一定非得要从一个Class文件获取，这里既可以从ZIP包中读取（例如从jar包或者war包中读取），也可以在运行时计算生成（动态代理），也可以由其它文件生成（比如将JSP文件转换成对应的Class类）

### 验证

这一阶段的主要目的就是为了确保Class文件的字节流中包含的信息是否符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。

### 准备

准备阶段是正式为类变量分配内存并设置类变量的初始值阶段，即在方法区中分配这些变量所使用的内存空间。

注意这里所说的初始值概念，比如一个类变量定义为： v = 8080，实际上变量v在准备阶段过后的初始值为0，而不是8080，将v赋值为808的put static指令是在程序被编译后，存放在类构造器方法之中。

但是注意如果使用的是以下申明

```
public static final int v = 8080;
```

在编译阶段会给v生成ConstantValue属性，在准备阶段虚拟机会根据ConstantValue属性将v赋值为8080

### 解析

解析阶段是指虚拟机将常量池中的符号引用替换为直接引用的过程。符号引用就是class文件中的类型常量

```
CONSTANT_CLASS_info
CONSTANT_Field_info
CONSTANT_Method_info
```

#### 符号引用

符号引用与虚拟机实现的布局无关，引用的目标并不一定要已经加载到内存中。各种虚拟机实现的内存布局可以各不相同，但是它们能接受的符号引用必须一致的，因为符号引用的字面量形式明确定义在Java虚拟机规范的Class的文件格式中。编译时，java类并不知道所引用的类的实际地址，因此只能使用符号引用来代替。比如org.simple.People类引用了org.simple.Language类，在编译时People类并不知道Language类的实际内存地址，因此只能使用符号org.simple.Language（假设是这个，当然实际中是由类似于CONSTANT_Class_info的常量来表示的）来表示Language类的地址。各种虚拟机实现的内存布局可能有所不同，但是它们能接受的符号引用都是一致的，因为符号引用的字面量形式明确定义在Java虚拟机规范的Class文件格式中

#### 直接引用

直接引用可以是指向目标的指针，相对于偏移量或是一个能直接定位到目标的句柄，如果有了直接引用，那引用的目标必定已经在内存中存在了。

### 初始化

初始化阶段是类加载的最后一个阶段，前面的类加载阶段之后，除了在加载阶段可以自定义类加载器以外，其它操作都是由JVM主导，到了初始化阶段，才开始真正指定类中定义的Java程序代码。