# MySQL

## ACID

事务的 四个特征（ACID）

事务具有四个特征：原子性（ Atomicity ）、一致性（ Consistency ）、隔离性（ Isolation ）和持续性（ Durability ）。这四个特性简称为 ACID 特性。

1 、原子性。事务是数据库的逻辑工作单位，事务中包含的各操作要么都做，要么都不做。 (由undolog保证)

2 、一致性。事 务执行的结果必须是使数据库从一个一致性状态变到另一个一致性状态。因此当数据库只包含成功事务提交的结果时，就说数据库处于一致性状态。如果数据库系统 运行中发生故障，有些事务尚未完成就被迫中断，这些未完成事务对数据库所做的修改有一部分已写入物理数据库，这时数据库就处于一种不正确的状态，或者说是 不一致的状态。（由其他三个特性共同保证）

3 、隔离性。一个事务的执行不能其它事务干扰。即一个事务内部的操作及使用的数据对其它并发事务是隔离的，并发执行的各个事务之间不能互相干扰。（由多版本并发控制（MVCC，Multiversion Concurrency Control）解决）

4 、持久性。也称永久性，指一个事务一旦提交，它对数据库中的数据的改变就应该是持久性的。接下来的其它操作或故障不应该对其执行结果有任何影响。（由redolog+binlog保证）

## MySQL隔离级别 

### 隔离级别由上之下依次增加 

- Read Uncommitted 读未提交 
  - 读未提交的内容。即事务a在读取操作，事务b在修改数据确未提交，a读取到b修改后的结果。（这叫脏读）
  - （产生脏读，不可重复读和幻读）
  - set session transaction isolation level read uncommitted;
- Read Committed 读且提交 
  - 读取已提交的内容。即事务a在做两次查询，而事务b在两次查询的中间做了一次修改数据并提交，导致两次查询结果不一致。（这叫不可重复读）
  - （产生不可重复读和幻读）
  - set session transaction isolation level read committed;
- Repeatable Read 可重复读 
  - 这是MySQL的默认事务隔离级别（不包括其他数据库）。即事务a在做一次修改将id为1的数据修改为id 2，而事务b在事务a未提交之前新增一条记录或者修改一条其他记录至id为1。（出现幻读） 而 InnoDB和Falcon存储引擎通过多版本并发控制（MVCC，Multiversion Concurrency Control）机制解决了该问题。
  - （产生幻读）
  - set session transaction isolation level repeatable read;
- Serializable 可序列化 
  - 这是最高的隔离级别，它通过强制事务排序，使不可能出现幻读等其他问题。他在每个读的数据行加上共享锁，容易导致大量的锁竞争和等待
  - set session transaction isolation level serializable;


## MVCC解决的问题是什么
 数据库并发场景有三种,分别为:
 1. 读读: 不存在任务问题,也不需要并发控制.
 2. 读写: 有线程安全问题,可能会造成事务隔离性问题,可能遇到脏读,幻读,不可重复读
 3. 写写: 有线程安全问题,可能为造成更新丢失  
  
 MVCC是一种用来解决读写冲突的无锁并发控制.也就是为事务分配单项增加的时间戳,为每一个修改保存一版版本号,版本与事务时间戳关联,读操作只读该事务开始前的数据库快照,所以MVCC可以为数据库解决以下问题:
 1. 在并发读写数据库时,可以做到在读操作时不用阻塞写操作,写操作也不用阻塞读操作,提高了数据库并发读写的性能.
 2. 解决脏读,幻读,不可重复读等事务隔离问题,但是不能解决写写导致的更新丢失问题. 

## MVCC实现原理

MVCC实现原理主要依赖于记录中的三个隐藏字段,undolog日志,以及read view来实现的.
### 隐藏字段
  数据库表的每行记录除了我们自定义的字段外,还有数据库隐式定义的一些字段: 
  1. DB_TRX_ID ,记录创建这条记录的或者最后一次修改该记录的事务id.
  2. DB_ROLL_PTR,回滚指针,指向这条记录的上一个版本,用于配合undolog进行事务回滚.(故第一次创建会为null)
  3. DB_ROW_ID,隐藏的主键,如果数据库没有主键,那么innodb才会自动生成一个row_id 

### Read view
 read view是事务进行快照读操作时生产的读视图.
 在innodb 中每个SQL语句执行前都会得到一个read_view。
 副本主要保存了当前数据库系统中正处于活跃（没有commit）的事务的ID号，其实简单的说这个副本中保存的是系统中当前不应该被本事务看到的其他事务id列表。
 
### Read view 的几个重要属性
- trx_ids: 当前系统活跃(未提交)事务版本号集合。
- low_limit_id: 创建当前read view 时当前系统活跃的事务最大版本号。
- up_limit_id: 创建当前read view 时系统活跃的事务最小版本号
- creator_trx_id: 创建当前read view的事务版本号； 

### Read view 匹配条件
（1）数据事务ID小于up_limit_id则显示

如果数据事务ID小于活跃事务的最小ID，则说明该数据是在所有活跃事务开启之前就已经存在的,可以显示。

（2）数据事务ID大于low_limit_id则不显示

如果数据事务ID大于活跃事务的最大ID，则说明该数据是在所有活跃事务开始之后才创建的，所以数据不予显示。

（3）数据事务ID 大于up_limit_id 并且小于low_limit_id

用数据事务ID 与trx_ids 集合中的事务ID进行匹配，如果事务ID不存在于活跃事务ID集合（说明事务已经commit了），或者数据事务ID等于creator_trx_id（这说明该数据就是当前事务修改的），满足上面的条件则可以显示。

（4）不满足read view条件时候，从undo log里面获取

当数据的事务ID不满足read view条件时候，从undo log里面获取数据的历史版本，然后数据历史版本事务号回头再来和read view 条件匹配 ，直到找到一条满足条件的历史数据，或者找不到则返回空结果；


## 快照读和当前读


### 快照读

快照读是指读取数据时不是读取最新版本的数据，而是基于历史版本读取的一个快照信息（mysql读取undo log历史版本) ，快照读可以使普通的SELECT 读取数据时不用对表数据进行加锁，从而解决了因为对数据库表的加锁而导致的两个如下问题

1、解决了因加锁导致的修改数据时无法对数据读取问题;

2、解决了因加锁导致读取数据时无法对数据进行修改的问题;

### 当前读

当前读是读取的数据库最新的数据，当前读和快照读不同，因为要读取最新的数据而且要保证事务的隔离性，所以当前读是需要对数据进行加锁的（Update delete insert select ....lock in share mode select for update 为当前读）


## MVCC和乐观锁的区别
### mvcc:解决读写冲突的无锁并发控制，
### occ (乐观锁)：解决写写冲突的无锁并发控制

[部分参考](https://zhuanlan.zhihu.com/p/52977862)